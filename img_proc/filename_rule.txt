oが小文字，Oが大文字を表す場合，下記の通りにする

・ファイル名: ooo_ooo.cpp
・クラス名: OooOoo
・関数名: ooooOooo
・ローカル変数: ooo_ooo
・グローバル変数: ooo_ooo_


-----------------------
/****************************************************************************************
 *	@Function
 *		generate pointcloud
****************************************************************************************/
// void FbControl::generatePointCloud(cv::Mat img_obj_region)
// {
// 	pcl::PointCloud<pcl::PointXYZRGB> cloud;
// 	const float depth_scale = 0.01f; // 深度スケール
// 	const float fx = 616.0f; // カメラの焦点距離
// 	const float fy = 616.0f;
// 	const float cx = 320.0f; // 画像中心のx座標
// 	const float cy = 240.0f; // 画像中心のy座標
// 	std::vector<std::vector<float>> coordinate;
// 	std::vector<float> coordinate_a;  

// 	for (int v = 0; v < img_obj_region.rows; v++)
// 	{
// 		for (int u = 0; u < img_obj_region.cols; u++)
// 		{
// 			//img_HSVの明度が0でなければ，処理を行う                
// 			int color = img_obj_region.at<cv::Vec3b>(v, u);
// 			if (color == 255)
// 			{
// 				uint16_t depth_value = depth_src.at<uint16_t>(v, u);

// 				pcl::PointXYZRGB point;
// 				point.z = depth_value * depth_scale;
// 				point.x = (u - cx) * point.z / fx;
// 				point.y = (v - cy) * point.z / fy;
// 				coordinate_a = {point.x, point.y, point.z};
// 				coordinate.push_back(coordinate_a);
				
// 				point.b = real_img.at<cv::Vec3b>(v, u)[0];
// 				point.g = real_img.at<cv::Vec3b>(v, u)[1];
// 				point.r = real_img.at<cv::Vec3b>(v, u)[2];
				
// 				// if( point.z < 2.0)
// 				cloud.push_back(point);
// 			}
// 		}
// 	}
// }


// //-------------------------------------------calc 2d deformation--------------------------------------
// if(!point_optflow_2d_prev_.empty())
// {
// 	// calculate LK-Optical flow
// 	std::vector<cv::Point2f> point_optflow_2d;
// 	std::vector<uchar> status;
// 	std::vector<float> err;
// 	cv::TermCriteria criteria = cv::TermCriteria((cv::TermCriteria::COUNT)+(cv::TermCriteria::EPS), 10, 0.03);
// 	cv::calcOpticalFlowPyrLK(img_obj_gray_prev_, img_obj_gray, point_optflow_2d_prev_, point_optflow_2d, status, err, cv::Size(20, 20), 2, criteria);

// 	// calculate deformation
// 	double deform_l = 0.0, deform_r = 0.0;
// 	for(int i = 0; i < point_optflow_2d.size(); i++)
// 	{
// 		// calculate diff
// 		double x = point_optflow_2d[i].x - point_optflow_2d_prev_[i].x;
// 		double y = point_optflow_2d[i].y - point_optflow_2d_prev_[i].y;

// 		if(abs(x) <= 1.0 && abs(y) <= 1.0)	// exclude outlier
// 		{
// 			// calc diff for each finger
// 			if(point_optflow_2d[i].x < centroid_obj_[0].x)
// 				deform_l = x;
// 			else
// 				deform_r = x;
			
// 			// check object move
// 			double obj_move_x = abs(centroid_obj_[0].x - centroid_obj_prev_.x);

// 			// calc deformation
// 			int obj_move_th = 2; //pixel
// 			if (obj_move_x < obj_move_th)
// 				deformation_total_ += (abs(deform_l) + abs(deform_r));
// 			else
// 				deformation_total_ += 0.0;	// object move means object is not deforming

// 			// normalize by the size of the object
// 			int deformation_ratio = deformation_total_ / point_optflow_2d_prev_.size();
// 			if( deformation_ratio > DEFORMATION_TH_ )
// 			{
// 				ROS_INFO("Meet IfG3");
// 				return true;
// 			}
// 		}
// 	}
// 	std::cout << "deformation_total_" << deformation_total_ << std::endl;
// 	std::cout << "------ " << std::endl;
// }